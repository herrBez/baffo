  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baffo</title>
    
    <!-- Link to the separate custom stylesheet -->
    <link rel="stylesheet" href="style.css"> 

    <!-- Highlight.js CSS for Ruby Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark-dimmed.min.css">
    
    <!-- Load Tailwind CSS for utility classes -->
    <script src="https://cdn.tailwindcss.com"></script>
    
  </head>
  <body class="font-sans">

    <div class="container">
      <h1>Baffo</h1>
      <h2>Transpile Logstash Pipelines to Elasticsearch Ingest Pipelines</h2>

<div class="main-layout">

  <div class="lhs">
    <h2 class="output-header stdout-header">Logstash Pipeline</h2>

    <div class="input-card">
      <div id="input-container">
        <!-- Textarea where user types -->
        <textarea id="code-input" rows="10" spellcheck="false"
                  oninput="updateHighlight()" 
                  onscroll="syncScroll(this, 'highlighted-code')"></textarea>

        <!-- Pre block for highlighting -->
        <div id="highlighted-code">
          <pre><code></code></pre>
        </div>
      </div>

      <div class="run-button-wrapper">
        <button onclick="run()" class="run-button">Transpile!</button>
      </div>
    </div>
  </div>

  <div class="rhs">
    <div class="output-grid">

      <div class="flex flex-col">
        <h2 class="output-header stdout-header">Standard Output (stdout) - JSON Formatted</h2>
        <pre id="stdout-container" class="output-box">
          <code id="stdout-code" class="language-json">No program executed yet.</code>
        </pre>
      </div>

      <div class="flex flex-col">
        <h2 class="output-header stderr-header">Standard Error (stderr) - JSON Log Lines</h2>
        <pre id="stderr-container" class="output-box">
          <code id="stderr-code" class="language-json">No program executed yet.</code>
        </pre>
      </div>

    </div>
  </div>
  
</div>
    

    <!-- WASM Runner -->
    <script src="wasm_exec.js"></script>
    <!-- Highlight.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- Highlight.js Language Definitions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/ruby.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <!-- ACTION: Added Properties language support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/properties.min.js"></script>
    
    <script>
      let go = new Go();
      
      // Updated element references to target the inner CODE elements
      const stdoutCodeElement = document.getElementById("stdout-code");
      const stderrCodeElement = document.getElementById("stderr-code");
      
      const inputElement = document.getElementById("code-input");
      const codeElement = document.querySelector('#highlighted-code code');
      
      // Store original console functions globally
      const originalConsoleLog = console.log;
      const originalConsoleError = console.error;
      
      // Buffers to collect the entire output stream during execution
      let stdoutBuffer = "";
      let stderrBuffer = ""; 

      // --- Highlight.js Setup ---

      function updateHighlight() {
          const content = inputElement.value;
          
          // ACTION: Use highlightAuto restricted to 'ruby' and 'properties'
          // This automatically detects the language and returns the highlighted HTML
          if (content.trim()) {
              const result = hljs.highlightAuto(content, ['properties']);
              codeElement.innerHTML = result.value;
              // Apply the detected language class for specific styling
              codeElement.className = `hljs language-${result.language}`;
          } else {
              codeElement.innerHTML = '';
              codeElement.className = '';
          }

          syncScroll(inputElement, 'highlighted-code');
      }

      function syncScroll(source, targetId) {
          const target = document.getElementById(targetId);
          target.scrollTop = source.scrollTop;
      }

      // --- I/O CAPTURE AND REDIRECTION ---

      function captureConsole(isEnabled) {
          if (isEnabled) {
              stdoutBuffer = "";
              stderrBuffer = ""; 

              console.log = function(...args) {
                  const message = args.join(' ') + '\n';
                  stdoutBuffer += message; 
              };
              
              console.error = function(...args) {
                  const message = args.join(' ') + '\n';
                  stderrBuffer += message; 
              };

          } else {
              console.log = originalConsoleLog;
              console.error = originalConsoleError;
          }
      }

      function filterAndSeparateStreams(stdoutInput, stderrInput) {
          const stdoutLines = stdoutInput.split('\n').filter(line => line.trim() !== '');
          let finalStdoutLines = [];
          let finalStderrLines = [...stderrInput.split('\n').filter(line => line.trim() !== '')]; 

          for (const line of stdoutLines) {
              try {
                  const json = JSON.parse(line);
                  if (json["log.level"]) {
                      finalStderrLines.push(line);
                  } else {
                      finalStdoutLines.push(line);
                  }
              } catch (e) {
                  finalStdoutLines.push(line);
              }
          }
          
          return {
              stdout: finalStdoutLines.join('\n'), 
              stderr: finalStderrLines.join('\n')
          };
      }
      
      function processOutput(targetElement, buffer, formatAsJson) {
          const trimmedBuffer = buffer.trim();
          
          // Reset element's Highlight.js state
          delete targetElement.dataset.highlighted;
          targetElement.classList.remove('hljs'); 
          targetElement.classList.remove('language-json');
          
          if (trimmedBuffer === "") {
              targetElement.textContent = `--- No output received. ---`;
              return;
          }

          if (formatAsJson) {
              try {
                  const jsonObject = JSON.parse(trimmedBuffer);
                  const formattedJson = JSON.stringify(jsonObject, null, 2);
                  
                  targetElement.textContent = formattedJson;
                  targetElement.classList.add('language-json');
                  hljs.highlightElement(targetElement);

              } catch (e) {
                  targetElement.textContent = trimmedBuffer;
                  targetElement.classList.add('language-json');
                  hljs.highlightElement(targetElement);
              }
          } else {
              targetElement.textContent = trimmedBuffer;
          }
      }

      // --- RUN FUNCTION ---
      async function run() {
        const inlineContent = inputElement.value;
        stdoutCodeElement.textContent = 'Running program... capturing output buffer.';
        stderrCodeElement.textContent = 'Running program... capturing error buffer.';

        if (go.exited) {
          go = new Go();
        }
        
        go.argv = [
            "baffo",             
            "transpile",
            // "--idiomatic=true",
            "--deal_with_error_locally=false",
            "--pipeline_threshold=10",
            "--fidelity=false",
            "--log_level=debug",
            "--inline=true",     
            inlineContent        
        ];

        captureConsole(true); 

        try {
          const result = await WebAssembly.instantiateStreaming(fetch("app.wasm"), go.importObject);
          await go.run(result.instance);
        } catch (e) {
          originalConsoleError("WASM Execution Error (Fatal):", e);
          stderrBuffer += `\n--- WASM RUNTIME ERROR (Fatal Crash) ---\n${e.message}\n`;
        } finally {
          const separated = filterAndSeparateStreams(stdoutBuffer, stderrBuffer);
          captureConsole(false);
          
          // Pass the inner CODE elements to the processor
          processOutput(stdoutCodeElement, separated.stdout, true); 
          processOutput(stderrCodeElement, separated.stderr, true);
        }
      }
      
      // --- Initial Setup Execution ---
      (function initialSetup() {
          inputElement.value = "input{\n}\n\nfilter{\n  mutate {\n    add_field => {\n      \"[test]\" => \"foo\"\n    }\n  }\n}\n\noutput{\n}";
          updateHighlight();
      })();
    </script>
  </body>
  </html>